#' This function is aimed at the application for my master's thesis and is
#' experimental. It performs the approximation means based test parallelized
#' over the permutations.
#'
#' @param cl: cluster object created by parallel package
#' @param approxQ: integer specifying the number of combinations to be used for
#' the approximation of the critical value
#' @param sample1: first sample, specified as a list where each element is one observation
#' @param sample2: second sample, specified as a list where each element is one observation
#' @param interpolation_mode: string that determines the mode of interpolation between
#' discrete measurement points. (Recommendation: 'linear')
#' @param domain: vector with beginning and endpoint of the closed interval
#' that is the domain of the stochastic processes
#' @param n_basis: if interpolation mode is choses as a basis based method,
#' this determines the number of basis functions used in the approximation
#' @param grid: grid used for the approximation of the mean function
#'
#' @return Realizations of the t-statistic for the Mean based test
#'
#' @export
means_tstats_par <- function(cl, approxQ = NULL, sample1, sample2,
                             interpolation_mode = "linear", domain = c(0, 1),
                             n_basis = NULL, grid = NULL) {
  helper_func <- function() {
    index_1 <- sample(x = 1:(length(sample1) + length(sample2)), size = length(sample1), replace = FALSE)
    index_2 <- setdiff(x = 1:(length(sample1) + length(sample2)), y = index_1)

    data <- append(sample1, sample2)
    perm_sample1 <- data[index_1]
    perm_sample2 <- data[index_2]

    tstat <- means_tstat(
      sample1 = perm_sample1, sample2 = perm_sample2, interpolation_mode = interpolation_mode,
      domain = domain, n_basis = n_basis, grid = grid
    )

    return(tstat)
  }

  tstats <- parallel::clusterApply(
    cl = cl, x = 1:approxQ,
    fun = helper_func
  )

  return(tstats)
}

#' This function is aimed at the application for my master's thesis and is
#' experimental. It performs the approximation CvM test parallelized
#' over the permutations.
#'
#' @param cl: cluster object created by parallel package
#' @param approxQ: integer specifying the number of combinations to be used for
#' the approximation of the critical value
#' @param sample1: first sample, specified as a list where each element is one observation
#' @param sample2: second sample, specified as a list where each element is one observation
#' @param type: type of computation to use (options are: 'fourier', 'eigen', and 'grid' )
#' @param domain: Domain of the functional observations
#' @param basis: basis generated by fda
#' @param eigen_func_obj: fda object containing the empirical eigenfunctions
#' @param grid: if type grid is chosen, this specifies the grid for the function
#' comparison
#' @param w_func: weight function for construction of measure
#' @param rho: a vector of length n_basis from a square summable sequence that is used
#' as scaling terms for the error terms
#' @param u_sample_func: function that can be used to sample from for the error terms
#' around the specified mean
#' @param n_func: number of functions used for the Monte-Carlo Integration in the
#' approximation of tau
#' @param ...: additional arguments given to u_sample_func
#'
#' @return Realizations of the t-statistic for the Cramer-von Mises test
#'
#' @export
CvM_tstats_par <- function(cl, approxQ = NULL, sample1, sample2, type = "fourier",
                           domain = c(0, 1), basis = NULL, grid = NULL, eigen_func_obj = NULL,
                           w_func, rho, u_sample_func, n_func, ...) {
  helper_func <- function() {
    index_1 <- sample(x = 1:(length(sample1) + length(sample2)), size = length(sample1), replace = FALSE)
    index_2 <- setdiff(x = 1:(length(sample1) + length(sample2)), y = index_1)

    data <- append(sample1, sample2)
    perm_sample1 <- data[index_1]
    perm_sample2 <- data[index_2]

    tstat <- cramer_von_mises_tstat_tstat(
      sample1 = perm_sample1, sample2 = perm_sample2, type = type,
      domain = domain, basis = basis, grid = grid, eigen_func_obj = eigen_func_obj,
      w_func = w_func, rho = rho, u_sample_func = u_sample_func, n_func = n_func, ...
    )

    return(tstat)
  }

  tstats <- parallel::clusterApply(
    cl = cl, x = 1:approxQ,
    fun = helper_func
  )
}
