#' This function calculates the means of the fourier coefficients as described
#' in section 5 of Bugni, Horowitz (2021) for a chosen basis and a function  w
#'
#' @param w_func: function that is large in the areas of the domain the
#' investigator expects differences in the distribution functions
#' @param basis: basis created by fda
#' @param n_basis: number of basis functions
#' @param domain: vector of two points (start and endpoint of the closed interval)
#'
#' @return: Vector of length n_basis containing the resulting means of the
#' fourier coefficients
fourier_basis_coef_means <- function(w_func, basis, n_basis, domain = c(0, 1)) {

  # extract basis functions as function objects
  basis_functions <- purrr::map(
    .x = 1:n_basis,
    .f = function(i) {
      basis_func <- function(x) {
        fda::eval.basis(evalarg = x, basisobj = basis)[1, i]
      }
    }
  )
  # calculate means of fourier coefficients
  coef_means <- purrr::map(
    .x = basis_functions,
    .f = function(f) {
      fourier_coef_mean(w_func = w_func, basis_func = f, domain = domain)
    }
  )
  # return vector of means of fourier coefficients
  return(unlist(coef_means))
}

#' This function calculates the desired mean of a fourier coefficient for
#' a single basis function
#'
#' @param w_func: function that is large in the areas of the domain the
#' investigator expects differences in the distribution functions
#' @param basis_func: basis function to calculate the fourier coefficient for
#' @param domain: vector of two points (start and endpoint of the closed interval)
#'
#' @return: Double that is the desired mean of the fourier coefficient
fourier_coef_mean <- function(w_func, basis_func, domain = c(0, 1)) {
  # define function to integrate over
  prod_func <- Vectorize(FUN = function(x) {
    return(w_func(x) * basis_func(x))
  })
  # integrate over product function
  coef_mean <- integrate(f = prod_func, lower = domain[1], upper = domain[2], subdivisions = 1000)$value
  # return appropriate mean object
  return(coef_mean)
}

#' This function samples a desired distribution of fourier coefficients
#' around a mean that's determined by the function w
#'
#' @param w_func: function that is large in the areas of the domain the
#' investigator expects differences in the distribution functions
#' @param basis: basis created by fda
#' @param n_basis: number of basis functions
#' @param rho: a vector of length n_basis from a square summable sequence that is used
#' as scaling terms for the error terms
#' @param domain: vector of two points (start and endpoint of the closed interval)
#' @param u_sample_func: function that can be used to sample from for the error terms
#' around the specified mean
#' @param ...: further parameters that are given to u_sample_func
#'
#' @return: A vector of length n_basis of sampled fourier coefficients
fourier_coef_sample <- function(w_func, basis = "fourier", n_basis, rho,
                                u_sample_func, domain = c(0, 1), ...) {
  # calculate means of fourier coefficients
  means <- fourier_basis_coef_means(
    w_func = w_func, basis = basis,
    n_basis = n_basis, domain = domain
  )

  # realizations of the fourier coefficients
  realizations <- means + rho * u_sample_func(n_basis = n_basis, ...)
  # return realizations
  return(realizations)
}

#' This function uses fourier coefficients generated by the function fourier_coef_sample
#' to generate realizations of the random function associated with the
#' measure mu.
#'
#' @param w_func: function that is large in the areas of the domain the
#' investigator expects differences in the distribution functions
#' @param basis: basis created by fda
#' @param n_basis: number of basis functions
#' @param rho: a vector of length n_basis from a square summable sequence that is used
#' as scaling terms for the error terms
#' @param domain: vector of two points (start and endpoint of the closed interval)
#' @param u_sample_func: function that can be used to sample from for the error terms
#' around the specified mean
#' @param ...: further parameters that are given to u_sample_func
#'
#' @return: A functional object that represents the sampled function
function_sample <- function(w_func, basis, n_basis, rho,
                            u_sample_func, domain = c(0, 1), ...) {

  # generate fourier coefficients
  fourier_coefs <- fourier_coef_sample(
    w_func = w_func, basis = basis, n_basis = n_basis, rho = rho,
    u_sample_func = u_sample_func, domain = domain, ...
  )

  # create an fd object with the generated fourier coefficients
  sample_function <- fda::fd(coef = fourier_coefs, basisobj = fourier_basis)
  # return an fd object!
  return(sample_function)
}

#' This function uses fourier coefficients generated by the function fourier_coef_sample
#' to generate realizations of the random function associated with the
#' measure mu. It uses the empirical eigenfunctions as the basis for the generation
#'
#' @param w_func: function that is large in the areas of the domain the
#' investigator expects differences in the distribution functions
#' @param eigen_func_obj: fda object containing the empirical eigenfunctions
#' @param n_basis: number of basis functions (here: empirical eigenfunctions)
#' @param rho: a vector of length n_basis from a square summable sequence that is used
#' as scaling terms for the error terms
#' @param domain: vector of two points (start and endpoint of the closed interval)
#' @param u_sample_func: function that can be used to sample from for the error terms
#' around the specified mean
#' @param ...: further parameters that are given to u_sample_func
#'
#' @return: A functional object that represents the sampled function
function_sample_eigen <- function(w_func, eigen_func_obj, n_basis, rho,
                                  u_sample_func, domain = c(0, 1), ...) {


}
