#' This function calculates the realization of the cramer-von mises type test
#' on two given samples (for fourier basis)
#'
#' @param sample1: first sample, specified as a list where each element is one observation
#' @param sample2: second sample, specified as a list where each element is one observation
#' @param domain: Domain of the functional observations
#' @param basis: basis generated by fda
#' @param w_func: weight function for construction of measure
#' @param rho: a vector of length n_basis from a square summable sequence that is used
#' as scaling terms for the error terms
#' @param u_sample_func: function that can be used to sample from for the error terms
#' around the specified mean
#' @param n_func: number of functions used for the Monte-Carlo Integration in the
#' approximation of tau
#'
#' @return: The value of the t-statistic for the Cramer-von Mises test
cramer_von_mises_tstat_fourier <- function(sample1, sample2, domain = c(0, 1), basis,
                                           w_func, rho, u_sample_func, n_func, ...) {
  # determine number of basis functions
  n_basis <- basis$nbasis
  # extract fourier coefficients from samples for sped up computation

  # create container for values of empirical distribution functions
  emp_dist_vals_s1 <- rep(x = NA_real_, times = n_func)
  emp_dist_vals_s2 <- rep(x = NA_real_, times = n_func)
  # find mean values for fourier coefficients
  coef_means <- fourier_basis_coef_means(w_func = w_func, basis = basis, n_basis = n_basis, domain = domain)
  # loop over number of functions for Monte-Carlo Approximation of functional integral
  for (i in 1:n_func) {
    # generate random function using the measure (!)
    # here we can save time by only generating the coefficients and not invoking
    # the fda package
    errors <- rho * u_sample_func(n_basis = n_basis, ...)
    cur_func <- fda::fd(coef = coef_means + errors, basis = basis)
    # calculate value of the empirical distribution functions
    emp_dist_vals_s1[i] <- empirical_dist_func_fourier(sample = sample1, func = cur_func, domain = domain, n_fourier_basis = n_basis)
    emp_dist_vals_s2[i] <- empirical_dist_func_fourier(sample = sample2, func = cur_func, domain = domain, n_fourier_basis = n_basis)
  }
  # calculate test statistic tau_hat
  tau_hat <- (length(sample1) + length(sample2)) * mean(x = (emp_dist_vals_s1 - emp_dist_vals_s2)^2, na.rm = FALSE)
  # return tau_hat
  return(tau_hat)
}

#' This function calculates the realization of the cramer-von mises type test
#' on two given samples (for empirical eigenbasis variant)
#'
#' @param sample1: first sample, specified as a list where each element is one observation
#' @param sample2: second sample, specified as a list where each element is one observation
#' @param domain: Domain of the functional observations
#' @param eigen_func_obj: fda object containing the empirical eigenfunctions
#' @param w_func: weight function for construction of measure
#' @param rho: a vector of length n_basis from a square summable sequence that is used
#' as scaling terms for the error terms
#' @param u_sample_func: function that can be used to sample from for the error terms
#' around the specified mean
#' @param n_basis: if basis based method is chosen in type, this determines the
#' number of basis functions used for the calculation
#' @param n_func: number of functions used for the Monte-Carlo Integration in the
#' approximation of tau
#'
#' @return: The value of the t-statistic for the Cramer-von Mises test
cramer_von_mises_tstat_eigen <- function(sample1, sample2, domain = c(0, 1), eigen_func_obj,
                                         w_func, rho, u_sample_func, n_func) {
  # create container for values of empirical distribution function
  emp_dist_vals <- rep(x = NA_real_, times = n_func)
  # loop over number of functions for Monte-Carlo Approximation of functional integral
  for (i in 1:n_func) {
    cur_func <- function_sample(w_func = w_func, basis = )
  }
}

#' This function calculates the realization of the cramer-von mises type test
#' on two given samples (for grid based variant)
#'
#' @param sample1: first sample, specified as a list where each element is one observation
#' @param sample2: second sample, specified as a list where each element is one observation
#' @param domain: Domain of the functional observations
#' @param eigen_func_obj: fda object containing the empirical eigenfunctions
#' @param w_func: weight function for construction of measure
#' @param rho: a vector of length n_basis from a square summable sequence that is used
#' as scaling terms for the error terms
#' @param u_sample_func: function that can be used to sample from for the error terms
#' around the specified mean
#' @param n_basis: if basis based method is chosen in type, this determines the
#' number of basis functions used for the calculation
#' @param grid: if type grid is chosen, this specifies the grid for the function
#' comparison
#' @param n_func: number of functions used for the Monte-Carlo Integration in the
#' approximation of tau
#'
#' @return: The value of the t-statistic for the Cramer-von Mises test
cramer_von_mises_tstat_grid <- function(sample1, sample2, domain = c(0, 1),
                                        w_func, rho, u_sample_func,
                                        grid = NULL, n_func) {
  # create container for values of empirical distribution function
  emp_dist_vals <- rep(x = NA_real_, times = n_func)
  # loop over number of functions for Monte-Carlo Approximation of functional integral
  for (i in 1:n_func) {
    cur_func <- function_sample(w_func = w_func, basis = )
  }
}
