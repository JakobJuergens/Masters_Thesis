#' This function calculates realizations of the cramer-von mises type test
#' on two given samples for a specified number of permutations
#'
#' @param full: Boolean that decides whether all combinations are considered
#' if FALSE, approxQ has to be provided
#' @param approxQ: integer specifying the number of combinations to be used for
#' the approximation of the critical value
#' @param sample1: first sample, specified as a list where each element is one observation
#' @param sample2: second sample, specified as a list where each element is one observation
#' @param type: type of computation to use (options are: 'fourier', 'eigen', and 'grid' )
#' @param domain: Domain of the functional observations
#' @param basis: basis generated by fda
#' @param eigen_func_obj: fda object containing the empirical eigenfunctions
#' @param grid: if type grid is chosen, this specifies the grid for the function
#' comparison
#' @param w_func: weight function for construction of measure
#' @param rho: a vector of length n_basis from a square summable sequence that is used
#' as scaling terms for the error terms
#' @param u_sample_func: function that can be used to sample from for the error terms
#' around the specified mean
#' @param n_func: number of functions used for the Monte-Carlo Integration in the
#' approximation of tau
#' @param ...: additional arguments given to u_sample_func
#'
#' @return: Realizations of the t-statistic for the Cramer-von Mises test
#' @export
cramer_von_mises_tstats <- function(full = TRUE, approxQ = NULL, sample1, sample2, type = "fourier",
                                    domain = c(0, 1), basis = NULL, grid = NULL, eigen_func_obj = NULL,
                                    w_func, rho, u_sample_func, n_func, ...) {
  if (full == TRUE) {
    tstats <- perm_tstats(
      full = full,
      sample1 = sample1, sample2 = sample2, t_stat_func = cramer_von_mises_tstat, type = type,
      domain = domain, basis = basis, grid = grid, eigen_func_obj = eigen_func_obj,
      w_func = w_func, rho = rho, u_sample_func = u_sample_func, n_func = n_func, ...
    )
  } else if (full == FALSE) {
    tstats <- perm_tstats(
      full = full, approxQ = approxQ, type = type,
      sample1 = sample1, sample2 = sample2, t_stat_func = cramer_von_mises_tstat,
      domain = domain, basis = basis, grid = grid, eigen_func_obj = eigen_func_obj,
      w_func = w_func, rho = rho, u_sample_func = u_sample_func, n_func = n_func, ...
    )
  }

  return(tstats)
}

#' This function calculates the realization of the cramer-von mises type test
#' on two given samples
#'
#' @param type: type of computation to use (options are: 'fourier', 'eigen', and 'grid' )
#' @param sample1: first sample, specified as a list where each element is one observation
#' @param sample2: second sample, specified as a list where each element is one observation
#' @param domain: Domain of the functional observations
#' @param basis: basis generated by fda
#' @param eigen_func_obj: fda object containing the empirical eigenfunctions
#' @param grid: if type grid is chosen, this specifies the grid for the function
#' comparison
#' @param w_func: weight function for construction of measure
#' @param rho: a vector of length n_basis from a square summable sequence that is used
#' as scaling terms for the error terms
#' @param u_sample_func: function that can be used to sample from for the error terms
#' around the specified mean
#' @param n_func: number of functions used for the Monte-Carlo Integration in the
#' approximation of tau
#' @param ...: additional arguments given to u_sample_func
#'
#' @return: The value of the t-statistic for the Cramer-von Mises test
cramer_von_mises_tstat <- function(type = "fourier", sample1, sample2, domain = c(0, 1), basis = NULL,
                                   grid = NULL, eigen_func_obj = NULL, w_func, rho, u_sample_func, n_func, ...) {
  if (type == "fourier") {
    return(cramer_von_mises_tstat_fourier(
      sample1 = sample1, sample2 = sample2, domain = domain, basis = basis,
      w_func = w_func, rho = rho, u_sample_func = u_sample_func, n_func = n_func, ...
    ))
  } else if (type == "eigen") {
    return(cramer_von_mises_tstat_eigen(
      sample1 = sample1, sample2 = sample2, domain = domain, eigen_func_obj = eigen_func_obj,
      w_func = w_func, rho = rho, u_sample_func = u_sample_func, n_func = n_func, ...
    ))
  } else if (type == "grid") {
    return(cramer_von_mises_tstat_grid(
      sample1 = sample1, sample2 = sample2, domain = domain, basis = basis,
      w_func = w_func, rho = rho, u_sample_func = u_sample_func,
      grid = grid, n_func = n_func, ...
    ))
  }
}

#' This function calculates the realization of the cramer-von mises type test
#' on two given samples (for fourier basis)
#'
#' @param sample1: first sample, specified as a list where each element is one observation
#' @param sample2: second sample, specified as a list where each element is one observation
#' @param domain: Domain of the functional observations
#' @param basis: basis generated by fda
#' @param w_func: weight function for construction of measure
#' @param rho: a vector of length n_basis from a square summable sequence that is used
#' as scaling terms for the error terms
#' @param u_sample_func: function that can be used to sample from for the error terms
#' around the specified mean
#' @param n_func: number of functions used for the Monte-Carlo Integration in the
#' approximation of tau
#' @param ...: additional arguments given to u_sample_func
#'
#' @return: The value of the t-statistic for the Cramer-von Mises test
cramer_von_mises_tstat_fourier <- function(sample1, sample2, domain = c(0, 1), basis,
                                           w_func, rho, u_sample_func, n_func, ...) {
  # determine number of basis functions
  n_basis <- basis$nbasis
  # extract fourier coefficients from samples for sped up computation

  # create container for values of empirical distribution functions
  emp_dist_vals_s1 <- rep(x = NA_real_, times = n_func)
  emp_dist_vals_s2 <- rep(x = NA_real_, times = n_func)
  # find mean values for fourier coefficients
  coef_means <- fourier_basis_coef_means(w_func = w_func, basis = basis, n_basis = n_basis, domain = domain)
  # loop over number of functions for Monte-Carlo Approximation of functional integral
  for (i in 1:n_func) {
    # generate random function using the measure (!)
    # here we can save time by only generating the coefficients and not invoking
    # the fda package
    errors <- rho * u_sample_func(n_basis = n_basis, ...)
    cur_func <- fda::fd(coef = coef_means + errors, basis = basis)
    # calculate value of the empirical distribution functions
    emp_dist_vals_s1[i] <- empirical_dist_func_fourier(sample = sample1, func = cur_func, domain = domain, n_fourier_basis = n_basis)
    emp_dist_vals_s2[i] <- empirical_dist_func_fourier(sample = sample2, func = cur_func, domain = domain, n_fourier_basis = n_basis)
  }
  # calculate test statistic tau_hat
  tau_hat <- (length(sample1) + length(sample2)) * mean(x = (emp_dist_vals_s1 - emp_dist_vals_s2)^2, na.rm = FALSE)
  # return tau_hat
  return(tau_hat)
}

#' This function calculates the realization of the cramer-von mises type test
#' on two given samples (for empirical eigenbasis variant)
#'
#' @param sample1: first sample, specified as a list where each element is one observation
#' @param sample2: second sample, specified as a list where each element is one observation
#' @param domain: Domain of the functional observations
#' @param eigen_func_obj: fda object containing the empirical eigenfunctions
#' @param w_func: weight function for construction of measure
#' @param rho: a vector of length n_basis from a square summable sequence that is used
#' as scaling terms for the error terms
#' @param u_sample_func: function that can be used to sample from for the error terms
#' around the specified mean
#' @param n_basis: if basis based method is chosen in type, this determines the
#' number of basis functions used for the calculation
#' @param n_func: number of functions used for the Monte-Carlo Integration in the
#' approximation of tau
#' @param ...: additional arguments given to u_sample_func
#'
#' @return: The value of the t-statistic for the Cramer-von Mises test
cramer_von_mises_tstat_eigen <- function(sample1, sample2, domain = c(0, 1), eigen_func_obj,
                                         w_func, rho, u_sample_func, n_func, ...) {
  # create container for values of empirical distribution function
  emp_dist_vals <- rep(x = NA_real_, times = n_func)
  # loop over number of functions for Monte-Carlo Approximation of functional integral
  for (i in 1:n_func) {
    cur_func <- function_sample(w_func = w_func, basis = )
  }
}

#' This function calculates the realization of the cramer-von mises type test
#' on two given samples (for grid based variant)
#'
#' @param sample1: first sample, specified as a list where each element is one observation
#' @param sample2: second sample, specified as a list where each element is one observation
#' @param domain: Domain of the functional observations
#' @param basis: basis generated by fda
#' @param w_func: weight function for construction of measure
#' @param rho: a vector of length n_basis from a square summable sequence that is used
#' as scaling terms for the error terms
#' @param u_sample_func: function that can be used to sample from for the error terms
#' around the specified mean
#' @param n_basis: if basis based method is chosen in type, this determines the
#' number of basis functions used for the calculation
#' @param grid: if type grid is chosen, this specifies the grid for the function
#' comparison
#' @param n_func: number of functions used for the Monte-Carlo Integration in the
#' approximation of tau
#' @param ...: additional arguments given to u_sample_func
#'
#' @return: The value of the t-statistic for the Cramer-von Mises test
cramer_von_mises_tstat_grid <- function(sample1, sample2, domain = c(0, 1), basis,
                                        w_func, rho, u_sample_func,
                                        grid = NULL, n_func, ...) {
  # create container for values of empirical distribution functions
  emp_dist_vals_s1 <- rep(x = NA_real_, times = n_func)
  emp_dist_vals_s2 <- rep(x = NA_real_, times = n_func)

  # find mean values for fourier coefficients
  coef_means <- matrix(
    data = rep(
      x = fourier_basis_coef_means(w_func = w_func, basis = basis, n_basis = n_basis, domain = domain),
      times = n_func
    ),
    nrow = n_basis, ncol = n_func, byrow = FALSE
  )
  # create error terms
  errors <- matrix(
    data = unlist(
      purrr::map(
        .x = 1:n_func,
        .f = function(i){rho * u_sample_func(n_basis = n_basis, ...)}
      )
    ), nrow = n_basis, ncol = n_func
  )
  # create coefficient matrix
  coefs_funcs <- coef_means + errors
  # create fda object
  fda_funcs <- fda::fd(coef = coefs_funcs, basisobj = basis)
  # translate samples into usual fda format
  sample1_f <- func_sample_transform2(orgnl_sample = sample1)
  sample2_f <- func_sample_transform2(orgnl_sample = sample2)
  # evaluate all at chosen comparison grid
  funcs_vals <- fda::eval.fd(evalarg = grid, fdobj = fda_funcs)
  s1_vals <- fda::eval.fd(evalarg = grid, fdobj = sample1_f)
  s2_vals <- fda::eval.fd(evalarg = grid, fdobj = sample2_f)
  # calculate differences and update empirical distribution functions
  for(i in 1:n_func){
    cur_func <- funcs_vals[,i]
    emp_dist_vals_s1[i] <- mean(
      x = unlist(
        purrr::map(
          .x = 1:length(sample1),
          .f = ~ all(cur_func >= s1_vals[,.x]))
        )
      )
    emp_dist_vals_s2[i] <- mean(
      x = unlist(
        purrr::map(
          .x = 1:length(sample2),
          .f = ~ all(cur_func >= s2_vals[,.x]))
      )
    )
  }
  # calculate test statistic tau_hat
  tau_hat <- (length(sample1) + length(sample2)) * mean(x = (emp_dist_vals_s1 - emp_dist_vals_s2)^2, na.rm = FALSE)
  # return tau_hat
  return(tau_hat)
}
